// Emacs style mode select   -*- C++ -*- 
//-----------------------------------------------------------------------------
//
// Copyright(C) 1993-1996 Id Software, Inc.
// Copyright(C) 2005 Simon Howard
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
// 02111-1307, USA.
//
// DESCRIPTION:
//
//-----------------------------------------------------------------------------

#include "system.h"
#include "graphic.h"
#include "fonts.h"
#include "timer.h"
#include "utils.h"
#include "fat32.h"
#include "jtag.h"
#include "bug.h"
#include "io.h"

#include "doomdef.h"
#include "doomstat.h"
#include "m_argv.h"
#include "m_config.h"
#include "m_misc.h"
#include "i_timer.h"
#include "i_video.h"
#include "s_sound.h"
#include "g_game.h"
#include "i_system.h"

#define EXCP_VECTOR	RAM

/* PS/2 rekisterit */
#define PS2_DATA		0
#define PS2_CONTROL		1

int print_x = 0, print_y = 0;

static boolean key_release = false, key_extended = false;

//
// EVENT HANDLING
//
// Events are asynchronous inputs generally generated by the game user.
// Events can be discarded if no responder claims them
//

#define MAXEVENTS		64

static event_t events[MAXEVENTS];
static int eventhead = 0;
static int eventtail = 0;

int terminal_enabled = 0;

void bug()
{
	disable_irqs();

	put_string("\nBUG TRAP\n");

	init_graphics(1);

	fill_rect(&screen, 0, 0, SCR_WIDTH, SCR_HEIGHT, 0);
	draw_string_shadow(&screen, 0, 0, "BUG TRAP");

	while (1) ;
}

/*
 * muuttaa näppäimistöltä tulevan merkin DOOM-merkiksi.
 * Lähde: http://www.computer-engineering.org/ps2keyboard/scancodes2.html
 */

static unsigned char translate_key[512] = {
	[0x0D] = KEY_TAB,
	[0x11] = KEY_RALT,	/* Oikeasti LALT */
	[0x12] = KEY_RSHIFT,	/* Oikeasti LSHIFT */
	[0x14] = KEY_RCTRL,	/* Oikeasti LCTRL */
	[0x15] = 'Q',
	[0x16] = '1',
	[0x1a] = 'Z',
	[0x1b] = 'S',
	[0x1c] = 'A',
	[0x1d] = 'W',
	[0x1e] = '2',
	[0x21] = 'C',
	[0x22] = 'X',
	[0x23] = 'D',
	[0x24] = 'E',
	[0x25] = '4',
	[0x26] = '3',
	[0x29] = ' ',
	[0x2a] = 'V',
	[0x2b] = 'F',
	[0x2c] = 'T',
	[0x2d] = 'R',
	[0x2e] = '5',
	[0x31] = 'N',
	[0x32] = 'B',
	[0x33] = 'H',
	[0x34] = 'G',
	[0x35] = 'Y',
	[0x36] = '6',
	[0x3a] = 'M',
	[0x3b] = 'J',
	[0x3c] = 'U',
	[0x3d] = '7',
	[0x3e] = '8',
	[0x42] = 'K',
	[0x43] = 'I',
	[0x44] = 'O',
	[0x45] = '0',
	[0x46] = '9',
	[0x4b] = 'L',
	[0x4d] = 'P',
	[0x59] = KEY_RSHIFT,
	[0x5A] = KEY_ENTER,
	[0x76] = KEY_ESCAPE,

	/* Laajennetut koodit: */
	[0x111] = KEY_RALT,
	[0x114] = KEY_RCTRL,
	[0x16B] = KEY_LEFTARROW,
	[0x172] = KEY_DOWNARROW,
	[0x174] = KEY_RIGHTARROW,
	[0x175] = KEY_UPARROW,
	[0x15A] = KEY_ENTER,
};

void exception_handler(uint32_t irqs_pending)
{
	unsigned int val;
	event_t ev;

	if (irqs_pending & 1u << TIMER_IRQ) {
		timer_irq();
	} else if (irqs_pending & 1u << PS2_IRQ) {
		/* luetaan merkki */
		val = IORD(PS2, PS2_DATA) & 0xff;

		if (val == 0xF0) {
			/* seuraava merkki on napin vapautus */
			key_release = true;
		} else if (val == 0xE0) {
			/* seuraava merkki on laajennettu */
			key_extended = true;
		} else {
			if (key_extended)
				val |= 0x100;
			if (translate_key[val]) {
				ev.type = key_release ? ev_keyup : ev_keydown;
				ev.data1 = translate_key[val];
				ev.data2 = tolower(translate_key[val]);
				I_PostEvent(&ev);
			}
			key_release = false;
			key_extended = false;
		}
	} else {
		bug();
	}
}

static void I_InitException(void)
{
	uint32_t *jump = (void *)EXCP_VECTOR;

	/* kirjoitetaan hyppykäsky */
	*jump = (uint32_t) & excp_wrapper << 4 | 0x1;

	/* varmistetaan että käskyt on kirjoitettu muistiin */
	flush_dcache(EXCP_VECTOR);

	/* muokataan jo ajettua koodia! */
	flush_icache(EXCP_VECTOR);

	write_irq_mask(0);
	enable_irqs();
}

//
// D_PostEvent
// Called by the I/O functions when input is detected
// IRQs disabled!
//
void I_PostEvent(event_t * ev)
{
	events[eventhead] = *ev;
	eventhead = (eventhead + 1) % MAXEVENTS;
}

// Read an event from the queue.

boolean I_PopEvent(event_t * ev)
{
	// No more events waiting.

	disable_irqs();
	if (eventtail == eventhead) {
		enable_irqs();
		return false;
	}

	*ev = events[eventtail];

	// Advance to the next event in the queue.

	eventtail = (eventtail + 1) % MAXEVENTS;

	enable_irqs();
	return true;
}

// Tactile feedback function, probably used for the Logitech Cyberman

void I_Tactile(int on, int off, int total)
{
}

//
// I_Init
//
void I_Init(void)
{
	init_graphics(1);

	terminal_enabled = 1;

	I_InitException();

	I_InitTimer();

	write_irq_mask(1u << TIMER_IRQ | 1u << PS2_IRQ);

	fat32_init();

	fill_rect(&screen, 0, 0, SCR_WIDTH, SCR_HEIGHT, 0);
}

//
// I_Quit
//

void I_Quit(void)
{
	I_Error("QUIT");
}

void I_WaitVBL(int count)
{
	msleep((count * 1000) / 70);
}

//
// I_Error
//
extern boolean demorecording;

static boolean already_quitting = false;

void I_Error(char *error, ...)
{
	if (already_quitting) {
		bug();
	} else {
		already_quitting = true;
	}

	I_Print("I_Error: ");
	I_Print(error);

	// Shutdown. Here might be other errors.

	if (demorecording) {
		G_CheckDemoStatus();
	}

	S_Shutdown();

	bug();
}

void I_Print(const char *s)
{
	put_string(s);

	if (!terminal_enabled)
		return;

	/* simuloidaan terminaalia */
	while (*s) {
		if (*s == '\n') {
			print_x = 0;
			print_y += get_text_height();
		} else if (*s == '\b') {
			if (print_x)
				print_x -= 8;
		} else {
			/* ei tukea vieritykselle */
			if (print_y < SCR_HEIGHT - get_text_height()) {
				draw_glyph(&screen, print_x, print_y, *s,
					   0xffff);
			}
			print_x += 8;
			if (print_x > SCR_WIDTH - 8) {
				print_x = 0;
				print_y += get_text_height();
			}
		}
		s++;
	}
	flip_page();
}
